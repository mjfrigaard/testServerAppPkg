---
title: "testServerPkgApp"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{testServerPkgApp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

```{r setup}
library(testServerPkgApp)
```

```{r}
#' Non-factor binary variables
#'
#' @param df a `data.frame` or `tibble`
#'
#' @return a vector of character or logical column names with two unique values
#'
#' @importFrom dplyr select where
#' @importFrom purrr set_names
#'
non_fct_binary_vars <- function(df) {
  no_fct_df <- dplyr::select(df, !dplyr::where(is.factor))
  # remove missing
  complete_df <- sapply(no_fct_df, na.omit)
  # get names
  nms <- names(complete_df)
  # set names in names
  df_nms <- purrr::set_names(nms)
  # check for binary variables
  check_binary <- function(x) {
    length(unique(x)) == 2
  }
  # get TRUE/FALSE binaries
  bin_log <- sapply(complete_df, check_binary)
  # subset names with binaries
  df_nms[bin_log]
}

#' Factor binary variables
#'
#' @param df a `data.frame` or `tibble`
#'
#' @return a vector of factor column names with two unique levels
#'
#' @importFrom dplyr select where
#' @importFrom purrr set_names
#'
fct_binary_vars <- function(df) {
  fct_df <- dplyr::select(df, dplyr::where(is.factor))
  # remove missing
  complete_df <- sapply(fct_df, na.omit)
  # get names
  nms <- names(complete_df)
  # set names in names
  df_nms <- purrr::set_names(nms)
  # check levels
  check_levels <- function(x) {
    length(levels(x)) == 2
  }
  bin_log <- sapply(complete_df, check_levels)
  # subset factor names with binaries
  df_nms[bin_log]
}

#' Binary variables (as vector)
#'
#' @section Variables with binary (two levels):
#'
#' This function is designed to quickly determine which variables have two
#' categorical levels. This is helpful for using `ggplot2::facet_wrap()`
#' or `ggplot2::facet_grid()`
#'
#' @param df a `data.frame` or `tibble`
#'
#' @return a vector of factor or character column names with two unique levels
#'
#' @export binary_vars
#'
#' @importFrom purrr set_names
#'
#' @examples
#' require(NHANES)
#' require(palmerpenguins)
#' binary_vars(df = NHANES::NHANES)
#' binary_vars(df = palmerpenguins::penguins)
#' # verify with str()
#' str(dplyr::select(
#'   NHANES::NHANES,
#'   dplyr::all_of(binary_vars(df = NHANES::NHANES))
#' ))
#' str(dplyr::select(
#'   palmerpenguins::penguins,
#'   dplyr::all_of(binary_vars(df = palmerpenguins::penguins))
#' ))
binary_vars <- function(df) {
  # non factors
  non_fct_cols <- ncol(dplyr::select(
    df,
    !dplyr::where(is.factor)
  ))
  # factors
  fct_cols <- ncol(dplyr::select(
    df,
    dplyr::where(is.factor)
  ))
  # if both column types exist
  if (non_fct_cols > 1 & fct_cols > 1) {
    non_fcts <- non_fct_binary_vars(df = df)
    fcts <- fct_binary_vars(df = df)
    bin_vars <- c(non_fcts, fcts)
    # if only non-factor columns exist
  } else if (non_fct_cols > 1 & fct_cols == 0) {
    bin_vars <- non_fct_binary_vars(df = df)
    # if only factor columns exist
  } else if (non_fct_cols == 0 & fct_cols > 1) {
    bin_vars <- fct_binary_vars(df = df)
    # some other kind of column (list?)
  } else {
    cli::cli_abort("Variables can't be converted to binary:
      (i.e., logical, character, factor)")
  }
  return(bin_vars)
}
```

